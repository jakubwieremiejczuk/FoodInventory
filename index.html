<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#1a1a2e">
  <title>Food Inventory</title>
  <link rel="manifest" href="manifest.json">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg: #1a1a2e;
      --surface: #16213e;
      --card: #0f3460;
      --accent: #e94560;
      --text: #eee;
      --text-dim: #8899aa;
      --green: #4ecca3;
      --red: #e94560;
      --radius: 12px;
      --safe-top: env(safe-area-inset-top);
      --safe-bottom: env(safe-area-inset-bottom);
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100dvh;
      padding-top: var(--safe-top);
      padding-bottom: calc(70px + var(--safe-bottom));
    }

    .header {
      position: sticky;
      top: 0;
      z-index: 100;
      background: var(--surface);
      padding: 12px 16px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .header h1 { font-size: 20px; font-weight: 700; }
    .header .count { font-size: 13px; color: var(--text-dim); }

    .search-bar {
      padding: 8px 16px 12px;
      background: var(--surface);
    }
    .search-bar input {
      width: 100%;
      padding: 10px 14px;
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,0.1);
      background: var(--bg);
      color: var(--text);
      font-size: 16px;
      outline: none;
    }
    .search-bar input:focus { border-color: var(--accent); }
    .search-bar input::placeholder { color: var(--text-dim); }

    .content { padding: 8px 16px 16px; }

    .category-group { margin-bottom: 16px; }
    .category-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 8px 0 4px;
      position: sticky;
      top: 82px;
      background: var(--bg);
      z-index: 10;
    }

    .item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--surface);
      border-radius: var(--radius);
      padding: 12px 14px;
      margin-bottom: 6px;
      cursor: pointer;
      transition: background 0.15s;
    }
    .item:active { background: var(--card); }
    .item-name { font-size: 15px; flex: 1; }
    .item-qty {
      font-size: 14px;
      color: var(--green);
      font-weight: 600;
      white-space: nowrap;
      margin-left: 12px;
    }

    .bottom-nav {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--surface);
      border-top: 1px solid rgba(255,255,255,0.05);
      display: flex;
      justify-content: space-around;
      padding: 8px 0 calc(8px + var(--safe-bottom));
      z-index: 100;
    }
    .nav-btn {
      background: none;
      border: none;
      color: var(--text-dim);
      font-size: 11px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      cursor: pointer;
      padding: 4px 16px;
    }
    .nav-btn.active { color: var(--accent); }
    .nav-btn svg { width: 24px; height: 24px; }

    .modal-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      z-index: 200;
      align-items: flex-end;
      justify-content: center;
    }
    .modal-overlay.open { display: flex; }
    .modal {
      background: var(--surface);
      width: 100%;
      max-width: 500px;
      border-radius: 20px 20px 0 0;
      padding: 20px 20px calc(20px + var(--safe-bottom));
      animation: slideUp 0.25s ease-out;
    }
    @keyframes slideUp {
      from { transform: translateY(100%); }
      to { transform: translateY(0); }
    }
    .modal h2 { font-size: 18px; margin-bottom: 16px; }
    .modal label {
      display: block;
      font-size: 13px;
      color: var(--text-dim);
      margin: 10px 0 4px;
    }
    .modal input, .modal select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.1);
      background: var(--bg);
      color: var(--text);
      font-size: 16px;
      outline: none;
    }
    .modal input:focus, .modal select:focus { border-color: var(--accent); }
    .modal-actions { display: flex; gap: 10px; margin-top: 20px; }
    .btn {
      flex: 1;
      padding: 12px;
      border-radius: var(--radius);
      border: none;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
    }
    .btn-primary { background: var(--accent); color: white; }
    .btn-secondary { background: rgba(255,255,255,0.1); color: var(--text); }
    .btn-danger { background: #c0392b; color: white; }

    .empty, .loading {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-dim);
    }

    /* --- Views --- */
    .view { display: none; }
    .view.active { display: block; }

    /* --- Recipe view --- */
    .recipe-input-group {
      display: flex;
      gap: 8px;
      padding: 8px 16px 12px;
      background: var(--surface);
    }
    .recipe-input-group input {
      flex: 1;
      padding: 10px 14px;
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,0.1);
      background: var(--bg);
      color: var(--text);
      font-size: 16px;
      outline: none;
    }
    .recipe-input-group input:focus { border-color: var(--accent); }
    .recipe-input-group input::placeholder { color: var(--text-dim); }
    .recipe-input-group button {
      padding: 10px 18px;
      border-radius: var(--radius);
      border: none;
      background: var(--accent);
      color: white;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
    }

    .recipe-title {
      font-size: 18px;
      font-weight: 700;
      padding: 12px 16px 4px;
    }

    .recipe-section-title {
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 12px 16px 4px;
    }
    .recipe-section-title.have { color: var(--green); }
    .recipe-section-title.need { color: var(--red); }

    .recipe-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--surface);
      border-radius: var(--radius);
      padding: 10px 14px;
      margin: 0 16px 6px;
    }
    .recipe-item .ri-text { font-size: 14px; flex: 1; }
    .recipe-item .ri-stock {
      font-size: 13px;
      font-weight: 600;
      white-space: nowrap;
      margin-left: 12px;
    }
    .recipe-item .ri-stock.have { color: var(--green); }
    .recipe-item .ri-stock.need { color: var(--red); }

    .cooking-btn-wrap {
      padding: 16px;
    }
    .cooking-btn {
      width: 100%;
      padding: 14px;
      border-radius: var(--radius);
      border: none;
      background: var(--green);
      color: #1a1a2e;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
    }
    .cooking-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* --- Receipt/Paragon view --- */
    .receipt-upload {
      padding: 16px;
      text-align: center;
    }
    .receipt-upload label {
      display: block;
      padding: 40px 20px;
      border: 2px dashed rgba(255,255,255,0.2);
      border-radius: var(--radius);
      cursor: pointer;
      color: var(--text-dim);
      font-size: 15px;
      transition: border-color 0.2s;
    }
    .receipt-upload label:active { border-color: var(--accent); }
    .receipt-upload input { display: none; }
    .receipt-upload svg { display: block; margin: 0 auto 8px; width: 40px; height: 40px; }

    .receipt-progress {
      padding: 16px;
      text-align: center;
      color: var(--text-dim);
    }
    .receipt-progress .bar {
      height: 4px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      margin: 12px 0;
      overflow: hidden;
    }
    .receipt-progress .bar-fill {
      height: 100%;
      background: var(--accent);
      border-radius: 2px;
      transition: width 0.3s;
    }

    .scan-item {
      display: flex;
      align-items: center;
      background: var(--surface);
      border-radius: var(--radius);
      padding: 10px 14px;
      margin: 0 16px 6px;
      gap: 10px;
    }
    .scan-item .si-check {
      width: 22px; height: 22px;
      border-radius: 4px;
      border: 2px solid var(--text-dim);
      cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      flex-shrink: 0;
    }
    .scan-item .si-check.checked { background: var(--green); border-color: var(--green); }
    .scan-item .si-info { flex: 1; min-width: 0; }
    .scan-item .si-de { font-size: 13px; color: var(--text-dim); }
    .scan-item .si-pl { font-size: 14px; }
    .scan-item .si-qty { font-size: 13px; color: var(--green); white-space: nowrap; }
    .scan-item .si-new { font-size: 11px; color: var(--accent); }
    .scan-item .si-edit {
      display: flex;
      gap: 6px;
      margin-top: 4px;
      align-items: center;
    }
    .scan-item .si-edit input {
      width: 70px;
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.15);
      background: var(--bg);
      color: var(--text);
      font-size: 14px;
      outline: none;
    }
    .scan-item .si-edit input:focus { border-color: var(--accent); }
    .scan-item .si-edit select {
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.15);
      background: var(--bg);
      color: var(--text);
      font-size: 13px;
      outline: none;
    }
    .scan-item .si-edit select:focus { border-color: var(--accent); }

    .scan-actions { padding: 16px; }
    .scan-actions button {
      width: 100%;
      padding: 14px;
      border-radius: var(--radius);
      border: none;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <!-- ===== LIST VIEW ===== -->
  <div id="view-list" class="view active">
    <div class="header">
      <h1>Food Inventory</h1>
      <span class="count" id="item-count"></span>
    </div>
    <div class="search-bar">
      <input type="text" id="search" placeholder="Szukaj...">
    </div>
    <div class="content" id="item-list">
      <div class="loading">Ładowanie...</div>
    </div>
  </div>

  <!-- ===== RECIPE VIEW ===== -->
  <div id="view-recipe" class="view">
    <div class="header">
      <h1>Przepis</h1>
    </div>
    <div class="recipe-input-group">
      <input type="url" id="recipe-url" placeholder="Wklej link do przepisu...">
      <button onclick="checkRecipe()">Sprawdź</button>
    </div>
    <div id="recipe-results" class="content">
      <div class="empty">Wklej link do przepisu i kliknij "Sprawdź"</div>
    </div>
  </div>

  <!-- ===== RECEIPT VIEW ===== -->
  <div id="view-receipt" class="view">
    <div class="header">
      <h1>Paragon</h1>
    </div>
    <div id="receipt-content">
      <div class="receipt-upload">
        <label for="receipt-file">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>
          Zrob zdjecie lub wybierz plik
        </label>
        <input type="file" id="receipt-file" accept="image/*" onchange="scanReceipt(this)">
      </div>
    </div>
  </div>

  <!-- ===== BOTTOM NAV ===== -->
  <nav class="bottom-nav">
    <button class="nav-btn active" id="nav-list" onclick="switchView('list')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><circle cx="4" cy="6" r="1" fill="currentColor"/><circle cx="4" cy="12" r="1" fill="currentColor"/><circle cx="4" cy="18" r="1" fill="currentColor"/></svg>
      Lista
    </button>
    <button class="nav-btn" id="nav-add" onclick="openAddModal()">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>
      Dodaj
    </button>
    <button class="nav-btn" id="nav-recipe" onclick="switchView('recipe')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/><line x1="8" y1="7" x2="16" y2="7"/><line x1="8" y1="11" x2="14" y2="11"/></svg>
      Przepis
    </button>
    <button class="nav-btn" id="nav-receipt" onclick="switchView('receipt')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="8" y1="13" x2="16" y2="13"/><line x1="8" y1="17" x2="13" y2="17"/></svg>
      Paragon
    </button>
  </nav>

  <!-- ===== ADD/EDIT MODAL ===== -->
  <div class="modal-overlay" id="modal-overlay" onclick="closeModalOnBackdrop(event)">
    <div class="modal" id="modal">
      <h2 id="modal-title">Dodaj produkt</h2>
      <label for="f-name">Nazwa</label>
      <input type="text" id="f-name" placeholder="np. Oliwa z oliwek">
      <label for="f-quantity">Ilość</label>
      <input type="number" id="f-quantity" placeholder="np. 500" step="any">
      <label for="f-unit">Jednostka</label>
      <select id="f-unit">
        <option value="g">g</option>
        <option value="ml">ml</option>
        <option value="puszka">puszka</option>
        <option value="słoik">słoik</option>
        <option value="opak.">opak.</option>
        <option value="szt.">szt.</option>
        <option value="butelka">butelka</option>
      </select>
      <label for="f-category">Kategoria</label>
      <input type="text" id="f-category" list="cat-list" placeholder="np. Konserwy">
      <datalist id="cat-list"></datalist>
      <div class="modal-actions" id="modal-actions">
        <button class="btn btn-secondary" onclick="closeModal()">Anuluj</button>
        <button class="btn btn-primary" id="btn-save" onclick="saveItem()">Dodaj</button>
      </div>
    </div>
  </div>

  <script>
    // --- Supabase REST API ---
    const API_URL = 'https://qkvkivmzlxjanjlymhsi.supabase.co/rest/v1';
    const FUNC_URL = 'https://qkvkivmzlxjanjlymhsi.supabase.co/functions/v1';
    const API_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFrdmtpdm16bHhqYW5qbHltaHNpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzE3OTA2OTIsImV4cCI6MjA4NzM2NjY5Mn0.hIWlrznnqvP5ClxZENXM4793o-6casfLa2R8Qf8isU4';

    const HEADERS = {
      'apikey': API_KEY,
      'Authorization': 'Bearer ' + API_KEY,
      'Content-Type': 'application/json',
      'Prefer': 'return=representation'
    };

    async function api(path, options = {}) {
      const res = await fetch(API_URL + path, { ...options, headers: { ...HEADERS, ...options.headers } });
      if (!res.ok) {
        const body = await res.text();
        throw new Error(`${res.status}: ${body}`);
      }
      return res.json();
    }

    let allItems = [];
    let editingId = null;

    // --- View switching ---
    function switchView(name) {
      document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
      document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
      document.getElementById('view-' + name).classList.add('active');
      document.getElementById('nav-' + name).classList.add('active');
    }

    // --- Categories (dynamic from data) ---
    function getCategories() {
      const cats = new Set();
      allItems.forEach(i => cats.add(i.category));
      // Also include any from custom receipt map
      Object.values(customMap).forEach(m => { if (m.category) cats.add(m.category); });
      return [...cats].sort();
    }

    function updateCatDatalist() {
      const dl = document.getElementById('cat-list');
      if (!dl) return;
      dl.innerHTML = getCategories().map(c => '<option value="' + escapeHtml(c) + '">').join('');
    }

    // --- Load items ---
    async function loadItems() {
      try {
        allItems = await api('/inventory?select=*&order=category,name');
        renderItems(allItems);
        updateCatDatalist();
      } catch (err) {
        document.getElementById('item-list').innerHTML =
          '<div class="empty">Błąd ładowania.<br><small>' + err.message + '</small></div>';
      }
    }

    // --- Render items ---
    function renderItems(items) {
      const container = document.getElementById('item-list');
      const countEl = document.getElementById('item-count');

      if (items.length === 0) {
        container.innerHTML = '<div class="empty">Brak produktów.</div>';
        countEl.textContent = '0 produktów';
        return;
      }

      countEl.textContent = items.length + ' produktów';

      const groups = {};
      items.forEach(item => {
        if (!groups[item.category]) groups[item.category] = [];
        groups[item.category].push(item);
      });

      let html = '';
      const sortedCategories = Object.keys(groups).sort();
      for (const cat of sortedCategories) {
        html += '<div class="category-group">';
        html += '<div class="category-title">' + cat + '</div>';
        for (const item of groups[cat]) {
          const qty = item.quantity === Math.floor(item.quantity)
            ? Math.floor(item.quantity) : item.quantity;
          html += '<div class="item" onclick="openEditModal(' + item.id + ')">'
            + '<span class="item-name">' + escapeHtml(item.name) + '</span>'
            + '<span class="item-qty">' + qty + ' ' + escapeHtml(item.unit) + '</span>'
            + '</div>';
        }
        html += '</div>';
      }

      container.innerHTML = html;
    }

    function escapeHtml(str) {
      const d = document.createElement('div');
      d.textContent = str;
      return d.innerHTML;
    }

    // --- Search ---
    document.getElementById('search').addEventListener('input', function(e) {
      const q = e.target.value.toLowerCase();
      if (!q) { renderItems(allItems); return; }
      renderItems(allItems.filter(function(item) {
        return item.name.toLowerCase().includes(q) || item.category.toLowerCase().includes(q);
      }));
    });

    // --- Modal ---
    function openAddModal() {
      editingId = null;
      document.getElementById('modal-title').textContent = 'Dodaj produkt';
      document.getElementById('f-name').value = '';
      document.getElementById('f-quantity').value = '';
      document.getElementById('f-unit').value = 'g';
      document.getElementById('f-category').value = getCategories()[0] || '';
      document.getElementById('btn-save').textContent = 'Dodaj';
      var existing = document.getElementById('btn-delete');
      if (existing) existing.remove();
      document.getElementById('modal-overlay').classList.add('open');
    }

    function openEditModal(id) {
      var item = allItems.find(function(i) { return i.id === id; });
      if (!item) return;
      editingId = id;
      document.getElementById('modal-title').textContent = 'Edytuj produkt';
      document.getElementById('f-name').value = item.name;
      document.getElementById('f-quantity').value = item.quantity;
      document.getElementById('f-unit').value = item.unit;
      document.getElementById('f-category').value = item.category;
      document.getElementById('btn-save').textContent = 'Zapisz';

      var actions = document.getElementById('modal-actions');
      if (!document.getElementById('btn-delete')) {
        var delBtn = document.createElement('button');
        delBtn.id = 'btn-delete';
        delBtn.className = 'btn btn-danger';
        delBtn.textContent = 'Usuń';
        delBtn.onclick = deleteItem;
        actions.insertBefore(delBtn, actions.firstChild);
      }
      document.getElementById('modal-overlay').classList.add('open');
    }

    function closeModal() {
      document.getElementById('modal-overlay').classList.remove('open');
    }

    function closeModalOnBackdrop(e) {
      if (e.target === document.getElementById('modal-overlay')) closeModal();
    }

    // --- Save ---
    async function saveItem() {
      var name = document.getElementById('f-name').value.trim();
      var quantity = parseFloat(document.getElementById('f-quantity').value);
      var unit = document.getElementById('f-unit').value;
      var category = document.getElementById('f-category').value;

      if (!name || isNaN(quantity)) { alert('Wypełnij nazwę i ilość.'); return; }

      var row = JSON.stringify({ name: name, quantity: quantity, unit: unit, category: category });

      try {
        if (editingId) {
          await api('/inventory?id=eq.' + editingId, { method: 'PATCH', body: row });
        } else {
          await api('/inventory', { method: 'POST', body: row });
        }
        closeModal();
        await loadItems();
      } catch (err) {
        alert('Błąd: ' + err.message);
      }
    }

    // --- Delete ---
    async function deleteItem() {
      if (!editingId) return;
      if (!confirm('Usunąć ten produkt?')) return;
      try {
        await fetch(API_URL + '/inventory?id=eq.' + editingId, { method: 'DELETE', headers: HEADERS });
        closeModal();
        await loadItems();
      } catch (err) {
        alert('Błąd: ' + err.message);
      }
    }

    // ==================== RECIPE FEATURE ====================

    let recipeMatches = []; // { ingredient, matched, inventoryItem, inventoryId, recipeQty, recipeUnit }

    // Strip Polish diacritics
    function stripPl(str) {
      return str.toLowerCase()
        .replace(/ą/g,'a').replace(/ć/g,'c').replace(/ę/g,'e')
        .replace(/ł/g,'l').replace(/ń/g,'n').replace(/ó/g,'o')
        .replace(/ś/g,'s').replace(/ź/g,'z').replace(/ż/g,'z');
    }

    // Crude Polish stemmer: chop common suffixes so declined forms match
    // "pszennej"→"pszenn", "mąki"→"mak", "cukru"→"cukr", "proszku"→"proszk"
    function stem(word) {
      let w = stripPl(word);
      // order matters — longest suffixes first
      const suffixes = [
        'owej','owego','owych','owym',
        'nej','nego','nych','nym',
        'iej','iego','iych','iem',
        'ej','ego','ych','ym',
        'ow','ow','ami','ach',
        'om','ie','ki','ku',
        'ce','ek','ka','ko',
        'ow','em','ze','y',
        'i','u','a','e','o'
      ];
      if (w.length <= 3) return w;
      for (const s of suffixes) {
        if (w.length - s.length >= 3 && w.endsWith(s)) {
          return w.slice(0, -s.length);
        }
      }
      return w;
    }

    // Get stems of all significant words in a string (3+ chars)
    function getStems(str) {
      return stripPl(str).split(/[\s,.\-–()/]+/)
        .filter(w => w.length >= 3)
        .map(w => stem(w));
    }

    // Parse quantity + unit from recipe ingredient text
    // e.g. "1,5 szklanki mąki pszennej - 250 g" → { qty: 250, unit: 'g' }
    // e.g. "3 jajka" → { qty: 3, unit: 'szt.' }
    function parseRecipeQty(text) {
      const t = text.toLowerCase();
      // Prefer explicit gram/ml amounts (often after dash)
      const gramMatch = t.match(/(\d+[.,]?\d*)\s*(g|kg|ml|l)\b/);
      if (gramMatch) {
        let val = parseFloat(gramMatch[1].replace(',', '.'));
        let unit = gramMatch[2];
        if (unit === 'kg') { val *= 1000; unit = 'g'; }
        if (unit === 'l') { val *= 1000; unit = 'ml'; }
        return { qty: val, unit };
      }
      // Count-based: look for leading number
      const countMatch = t.match(/^(\d+[.,]?\d*)/);
      if (countMatch) {
        return { qty: parseFloat(countMatch[1].replace(',', '.')), unit: 'szt.' };
      }
      return { qty: 1, unit: 'szt.' };
    }

    // Score how well an inventory item matches a recipe ingredient (0 = no match)
    function matchScore(invName, ingText) {
      const invStems = getStems(invName);
      const ingStems = getStems(ingText);
      if (invStems.length === 0) return 0;

      let matched = 0;
      for (const is of invStems) {
        // Check if any ingredient stem starts with the same root (or vice versa)
        for (const gs of ingStems) {
          if (is.length >= 3 && gs.length >= 3) {
            // Share at least 3-char prefix
            const minLen = Math.min(is.length, gs.length);
            const prefix = Math.min(minLen, 4); // compare first 4 chars
            if (is.slice(0, prefix) === gs.slice(0, prefix)) {
              matched++;
              break;
            }
          }
        }
      }
      // Require all inventory name stems to match
      return matched === invStems.length ? matched : 0;
    }

    async function checkRecipe() {
      const url = document.getElementById('recipe-url').value.trim();
      if (!url) { alert('Wklej link do przepisu.'); return; }

      const results = document.getElementById('recipe-results');
      results.innerHTML = '<div class="loading">Pobieram przepis...</div>';

      try {
        const res = await fetch(FUNC_URL + '/fetch-recipe', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + API_KEY },
          body: JSON.stringify({ url })
        });
        if (!res.ok) {
          const t = await res.text();
          throw new Error(t);
        }
        const data = await res.json();

        if (!data.ingredients || data.ingredients.length === 0) {
          results.innerHTML = '<div class="empty">Nie udało się znaleźć składników w tym przepisie.</div>';
          return;
        }

        // Make sure inventory is loaded
        if (allItems.length === 0) await loadItems();

        // Match ingredients against inventory using stem matching
        recipeMatches = data.ingredients.map(ingText => {
          let bestMatch = null;
          let bestScore = 0;
          for (const inv of allItems) {
            const score = matchScore(inv.name, ingText);
            if (score > bestScore) {
              bestScore = score;
              bestMatch = inv;
            }
          }
          const parsed = parseRecipeQty(ingText);
          // Determine if we have enough
          // status: 'have' = enough, 'low' = found but not enough, 'need' = not in inventory
          let status = 'need';
          let shortage = 0;
          if (bestMatch) {
            const sameUnit = (bestMatch.unit === parsed.unit) ||
              (['g','ml'].includes(bestMatch.unit) && ['g','ml'].includes(parsed.unit));
            if (sameUnit && bestMatch.quantity >= parsed.qty) {
              status = 'have';
            } else if (sameUnit) {
              status = 'low';
              shortage = Math.ceil(parsed.qty - bestMatch.quantity);
            } else {
              // Different units — can't compare precisely, assume have
              status = 'have';
            }
          }
          return {
            ingredient: ingText,
            matched: !!bestMatch,
            status,
            shortage,
            inventoryItem: bestMatch,
            inventoryId: bestMatch ? bestMatch.id : null,
            recipeQty: parsed.qty,
            recipeUnit: parsed.unit
          };
        });

        renderRecipeResults(data.title || 'Przepis', recipeMatches);
      } catch (err) {
        results.innerHTML = '<div class="empty">Błąd: ' + escapeHtml(err.message) + '</div>';
      }
    }

    function renderRecipeResults(title, matches) {
      const results = document.getElementById('recipe-results');
      const haveList = matches.filter(m => m.status === 'have');
      const lowList = matches.filter(m => m.status === 'low');
      const needList = matches.filter(m => m.status === 'need');

      let html = '<div class="recipe-title">' + escapeHtml(title) + '</div>';

      if (haveList.length > 0) {
        html += '<div class="recipe-section-title have">Masz (' + haveList.length + ')</div>';
        for (const m of haveList) {
          const inv = m.inventoryItem;
          const qty = inv.quantity === Math.floor(inv.quantity) ? Math.floor(inv.quantity) : inv.quantity;
          html += '<div class="recipe-item">'
            + '<span class="ri-text">' + escapeHtml(m.ingredient)
            + '<br><small style="color:var(--text-dim)">potrzeba: ' + m.recipeQty + ' ' + m.recipeUnit + ' · masz: ' + qty + ' ' + escapeHtml(inv.unit) + '</small>'
            + '</span>'
            + '<span class="ri-stock have">✓</span>'
            + '</div>';
        }
      }

      if (lowList.length > 0) {
        html += '<div class="recipe-section-title" style="color:#f39c12">Za mało (' + lowList.length + ')</div>';
        for (const m of lowList) {
          const inv = m.inventoryItem;
          const qty = inv.quantity === Math.floor(inv.quantity) ? Math.floor(inv.quantity) : inv.quantity;
          html += '<div class="recipe-item">'
            + '<span class="ri-text">' + escapeHtml(m.ingredient)
            + '<br><small style="color:var(--text-dim)">potrzeba: ' + m.recipeQty + ' ' + m.recipeUnit + ' · masz: ' + qty + ' ' + escapeHtml(inv.unit) + ' · <b style="color:#f39c12">dokup ' + m.shortage + ' ' + escapeHtml(inv.unit) + '</b></small>'
            + '</span>'
            + '<span class="ri-stock" style="color:#f39c12">⚠</span>'
            + '</div>';
        }
      }

      if (needList.length > 0) {
        html += '<div class="recipe-section-title need">Do kupienia (' + needList.length + ')</div>';
        for (const m of needList) {
          html += '<div class="recipe-item">'
            + '<span class="ri-text">' + escapeHtml(m.ingredient) + '</span>'
            + '<span class="ri-stock need">brak</span>'
            + '</div>';
        }
      }

      if (haveList.length > 0 || lowList.length > 0) {
        html += '<div class="cooking-btn-wrap">'
          + '<button class="cooking-btn" onclick="startCooking()">Gotuję!</button>'
          + '</div>';
      }

      results.innerHTML = html;
    }

    async function startCooking() {
      const matched = recipeMatches.filter(m => m.matched);
      if (matched.length === 0) return;

      const names = matched.map(m => m.inventoryItem.name).join(', ');
      if (!confirm('Użyć tych składników?\n\n' + names + '\n\nIlości zostaną zmniejszone.')) return;

      const btn = document.querySelector('.cooking-btn');
      btn.disabled = true;
      btn.textContent = 'Aktualizuję...';

      try {
        for (const m of matched) {
          const inv = m.inventoryItem;
          // Deduct the parsed recipe quantity
          let deduct = m.recipeQty || 1;
          // If units match (both g, both ml), deduct directly
          // If recipe unit is szt. and inv is countable, deduct count
          // If units don't match, deduct 1 as fallback
          if (['g', 'ml'].includes(inv.unit) && ['g', 'ml'].includes(m.recipeUnit)) {
            // direct deduction
          } else if (!['g', 'ml'].includes(inv.unit)) {
            deduct = m.recipeQty || 1;
          } else {
            // recipe says szt. but inventory is in g — estimate or deduct 1 portion
            deduct = Math.min(m.recipeQty * 50, inv.quantity);
          }
          let newQty = inv.quantity - deduct;

          if (newQty <= 0) {
            await fetch(API_URL + '/inventory?id=eq.' + inv.id, { method: 'DELETE', headers: HEADERS });
          } else {
            await api('/inventory?id=eq.' + inv.id, {
              method: 'PATCH',
              body: JSON.stringify({ quantity: newQty })
            });
          }
        }

        btn.textContent = 'Gotowe!';
        await loadItems();

        // Re-check matches with updated inventory
        setTimeout(() => {
          const url = document.getElementById('recipe-url').value.trim();
          if (url) checkRecipe();
        }, 1000);
      } catch (err) {
        alert('Błąd: ' + err.message);
        btn.disabled = false;
        btn.textContent = 'Gotuję!';
      }
    }

    // ==================== RECEIPT SCANNER ====================

    // German → Polish grocery mapping (keyword → {name, unit, category})
    const DE_PL_MAP = {
      // Vegetables / Fruits
      'möhren': { name: 'Marchewka', unit: 'szt.', category: 'Warzywa i owoce', qty: 1 },
      'karotten': { name: 'Marchewka', unit: 'szt.', category: 'Warzywa i owoce', qty: 1 },
      'broccoli': { name: 'Brokuł', unit: 'szt.', category: 'Warzywa i owoce', qty: 1 },
      'brokkoli': { name: 'Brokuł', unit: 'szt.', category: 'Warzywa i owoce', qty: 1 },
      'petersilie': { name: 'Pietruszka', unit: 'szt.', category: 'Warzywa i owoce', qty: 1 },
      'avocado': { name: 'Awokado', unit: 'szt.', category: 'Warzywa i owoce', qty: 1 },
      'sellerie': { name: 'Seler naciowy', unit: 'szt.', category: 'Warzywa i owoce', qty: 1 },
      'staudensellerie': { name: 'Seler naciowy', unit: 'szt.', category: 'Warzywa i owoce', qty: 1 },
      'tomaten': { name: 'Pomidory', unit: 'szt.', category: 'Warzywa i owoce', qty: 1 },
      'datteltomaten': { name: 'Pomidorki daktylowe', unit: 'opak.', category: 'Warzywa i owoce', qty: 1 },
      'paprika': { name: 'Papryka', unit: 'szt.', category: 'Warzywa i owoce', qty: 1 },
      'zwiebel': { name: 'Cebula', unit: 'szt.', category: 'Warzywa i owoce', qty: 1 },
      'knoblauch': { name: 'Czosnek', unit: 'szt.', category: 'Warzywa i owoce', qty: 1 },
      'kartoffel': { name: 'Ziemniaki', unit: 'kg', category: 'Warzywa i owoce', qty: 1 },
      'gurke': { name: 'Ogórek', unit: 'szt.', category: 'Warzywa i owoce', qty: 1 },
      'zucchini': { name: 'Cukinia', unit: 'szt.', category: 'Warzywa i owoce', qty: 1 },
      'spinat': { name: 'Szpinak', unit: 'opak.', category: 'Warzywa i owoce', qty: 1 },
      'salat': { name: 'Sałata', unit: 'szt.', category: 'Warzywa i owoce', qty: 1 },
      'pilze': { name: 'Grzyby', unit: 'opak.', category: 'Warzywa i owoce', qty: 1 },
      'champignon': { name: 'Pieczarki', unit: 'opak.', category: 'Warzywa i owoce', qty: 1 },
      'äpfel': { name: 'Jabłka', unit: 'kg', category: 'Warzywa i owoce', qty: 1 },
      'apfel': { name: 'Jabłka', unit: 'kg', category: 'Warzywa i owoce', qty: 1 },
      'banane': { name: 'Banany', unit: 'kg', category: 'Warzywa i owoce', qty: 1 },
      'zitrone': { name: 'Cytryna', unit: 'szt.', category: 'Warzywa i owoce', qty: 1 },
      'ingwer': { name: 'Imbir', unit: 'szt.', category: 'Warzywa i owoce', qty: 1 },
      'lauch': { name: 'Por', unit: 'szt.', category: 'Warzywa i owoce', qty: 1 },
      'mais': { name: 'Kukurydza', unit: 'puszka', category: 'Konserwy', qty: 1 },

      // Dairy
      'mozzarella': { name: 'Mozzarella', unit: 'opak.', category: 'Nabiał', qty: 1 },
      'käse': { name: 'Ser', unit: 'opak.', category: 'Nabiał', qty: 1 },
      'grillkäse': { name: 'Ser halloumi', unit: 'opak.', category: 'Nabiał', qty: 1 },
      'hallumi': { name: 'Ser halloumi', unit: 'opak.', category: 'Nabiał', qty: 1 },
      'halloumi': { name: 'Ser halloumi', unit: 'opak.', category: 'Nabiał', qty: 1 },
      'milch': { name: 'Mleko', unit: 'butelka', category: 'Nabiał', qty: 1 },
      'joghurt': { name: 'Jogurt', unit: 'opak.', category: 'Nabiał', qty: 1 },
      'butter': { name: 'Masło', unit: 'opak.', category: 'Nabiał', qty: 1 },
      'sahne': { name: 'Śmietana', unit: 'opak.', category: 'Nabiał', qty: 1 },
      'schmand': { name: 'Śmietana', unit: 'opak.', category: 'Nabiał', qty: 1 },
      'quark': { name: 'Twaróg', unit: 'opak.', category: 'Nabiał', qty: 1 },
      'eier': { name: 'Jajka', unit: 'opak.', category: 'Nabiał', qty: 1 },
      'ei': { name: 'Jajka', unit: 'opak.', category: 'Nabiał', qty: 1 },

      // Meat
      'hackfleisch': { name: 'Mięso mielone', unit: 'opak.', category: 'Mięso', qty: 1 },
      'hähnchen': { name: 'Kurczak', unit: 'opak.', category: 'Mięso', qty: 1 },
      'huhn': { name: 'Kurczak', unit: 'opak.', category: 'Mięso', qty: 1 },
      'hühnchen': { name: 'Kurczak', unit: 'opak.', category: 'Mięso', qty: 1 },
      'schnitzel': { name: 'Sznycel', unit: 'opak.', category: 'Mięso', qty: 1 },
      'wurst': { name: 'Kiełbasa', unit: 'opak.', category: 'Mięso', qty: 1 },
      'schinken': { name: 'Szynka', unit: 'opak.', category: 'Mięso', qty: 1 },
      'lachs': { name: 'Łosoś', unit: 'opak.', category: 'Mięso', qty: 1 },
      'fisch': { name: 'Ryba', unit: 'opak.', category: 'Mięso', qty: 1 },
      'rind': { name: 'Wołowina', unit: 'opak.', category: 'Mięso', qty: 1 },
      'schwein': { name: 'Wieprzowina', unit: 'opak.', category: 'Mięso', qty: 1 },

      // Flour, pasta, grains
      'mehl': { name: 'Mąka pszenna', unit: 'g', category: 'Makarony i mąki', qty: 1000 },
      'dinkel': { name: 'Mąka orkiszowa', unit: 'g', category: 'Makarony i mąki', qty: 1000 },
      'nudel': { name: 'Makaron', unit: 'g', category: 'Makarony i mąki', qty: 500 },
      'pasta': { name: 'Makaron', unit: 'g', category: 'Makarony i mąki', qty: 500 },
      'spaghetti': { name: 'Spaghetti', unit: 'g', category: 'Makarony i mąki', qty: 500 },
      'fettuc': { name: 'Fettuccine', unit: 'g', category: 'Makarony i mąki', qty: 500 },
      'mezzane': { name: 'Fettuccine', unit: 'g', category: 'Makarony i mąki', qty: 500 },
      'reis': { name: 'Ryż', unit: 'g', category: 'Kasze i rośliny strączkowe', qty: 500 },
      'hafer': { name: 'Płatki owsiane', unit: 'opak.', category: 'Makarony i mąki', qty: 1 },
      'haferflocken': { name: 'Płatki owsiane', unit: 'opak.', category: 'Makarony i mąki', qty: 1 },
      'haferfein': { name: 'Płatki owsiane drobne', unit: 'opak.', category: 'Makarony i mąki', qty: 1 },
      'masa harina': { name: 'Masa harina', unit: 'opak.', category: 'Makarony i mąki', qty: 1 },

      // Bread
      'brot': { name: 'Chleb', unit: 'szt.', category: 'Pieczywo', qty: 1 },
      'brötchen': { name: 'Bułki', unit: 'szt.', category: 'Pieczywo', qty: 1 },
      'toast': { name: 'Chleb tostowy', unit: 'opak.', category: 'Pieczywo', qty: 1 },

      // Baking
      'zucker': { name: 'Cukier', unit: 'g', category: 'Cukier i sól', qty: 1000 },
      'zuckerback': { name: 'Cukier', unit: 'g', category: 'Cukier i sól', qty: 1000 },
      'salz': { name: 'Sól morska', unit: 'g', category: 'Cukier i sól', qty: 500 },
      'hefe': { name: 'Drożdże', unit: 'szt.', category: 'Pieczenie', qty: 1 },
      'backpulver': { name: 'Proszek do pieczenia', unit: 'szt.', category: 'Pieczenie', qty: 1 },
      'vanille': { name: 'Cukier waniliowy', unit: 'szt.', category: 'Pieczenie', qty: 1 },
      'kakao': { name: 'Kakao', unit: 'opak.', category: 'Pieczenie', qty: 1 },
      'schokolade': { name: 'Czekolada', unit: 'opak.', category: 'Pieczenie', qty: 1 },
      'stärke': { name: 'Skrobia kukurydziana', unit: 'opak.', category: 'Pieczenie', qty: 1 },
      'speisestärke': { name: 'Skrobia kukurydziana', unit: 'opak.', category: 'Pieczenie', qty: 1 },

      // Condiments
      'öl': { name: 'Olej', unit: 'butelka', category: 'Przyprawy i sosy', qty: 1 },
      'olivenöl': { name: 'Oliwa z oliwek', unit: 'butelka', category: 'Przyprawy i sosy', qty: 1 },
      'essig': { name: 'Ocet', unit: 'butelka', category: 'Przyprawy i sosy', qty: 1 },
      'senf': { name: 'Musztarda', unit: 'słoik', category: 'Przyprawy i sosy', qty: 1 },
      'ketchup': { name: 'Ketchup', unit: 'butelka', category: 'Przyprawy i sosy', qty: 1 },
      'sojasoße': { name: 'Sos sojowy', unit: 'butelka', category: 'Przyprawy i sosy', qty: 1 },
      'sojasauce': { name: 'Sos sojowy', unit: 'butelka', category: 'Przyprawy i sosy', qty: 1 },
      'pesto': { name: 'Pesto', unit: 'słoik', category: 'Przyprawy i sosy', qty: 1 },

      // Canned
      'kichererbsen': { name: 'Ciecierzyca', unit: 'puszka', category: 'Konserwy', qty: 1 },
      'bohnen': { name: 'Fasola', unit: 'puszka', category: 'Konserwy', qty: 1 },
      'linsen': { name: 'Soczewica', unit: 'puszka', category: 'Konserwy', qty: 1 },
      'oliven': { name: 'Oliwki', unit: 'słoik', category: 'Konserwy', qty: 1 },
      'passata': { name: 'Passata pomidorowa', unit: 'opak.', category: 'Konserwy', qty: 1 },
      'kokosmilch': { name: 'Mleko kokosowe', unit: 'puszka', category: 'Konserwy', qty: 1 },

      // Nuts & seeds
      'nüsse': { name: 'Orzechy', unit: 'g', category: 'Orzechy i nasiona', qty: 200 },
      'mandeln': { name: 'Migdały', unit: 'g', category: 'Orzechy i nasiona', qty: 200 },
      'walnüsse': { name: 'Orzechy włoskie', unit: 'g', category: 'Orzechy i nasiona', qty: 200 },
      'erdnüsse': { name: 'Orzeszki ziemne', unit: 'g', category: 'Orzechy i nasiona', qty: 200 },
      'sesam': { name: 'Sezam', unit: 'g', category: 'Orzechy i nasiona', qty: 200 },
      'sonnenblumenkerne': { name: 'Pestki słonecznika', unit: 'g', category: 'Orzechy i nasiona', qty: 200 },

      // Drinks
      'wasser': { name: 'Woda', unit: 'butelka', category: 'Napoje', qty: 1 },
      'saft': { name: 'Sok', unit: 'butelka', category: 'Napoje', qty: 1 },
      'kaffee': { name: 'Kawa', unit: 'opak.', category: 'Napoje', qty: 1 },
      'tee': { name: 'Herbata', unit: 'opak.', category: 'Napoje', qty: 1 },

      // Other
      'tofu': { name: 'Tofu', unit: 'opak.', category: 'Inne', qty: 1 },
      'pflanzk': { name: 'Masło roślinne', unit: 'opak.', category: 'Nabiał', qty: 1 },
    };

    // Parse OCR text into receipt line items
    function parseReceiptLines(text) {
      const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 2);
      const items = [];
      // Typical Lidl receipt line: "Product Name    1,99 A"
      // or with quantity: "0,536 kg x 1,99 EUR/kg"
      // We look for lines that have a price pattern
      const priceRe = /(\d+[.,]\d{2})\s*[A-B]?\s*$/;
      const qtyLineRe = /^(\d+[.,]\d+)\s*kg\s*x/i;
      const countLineRe = /^(\d+)\s*x\s/i;

      let pendingQtyKg = null;
      let pendingCount = null;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        // Check if this is a quantity line (e.g. "0,536 kg x 1,99 EUR/kg")
        const qtyMatch = line.match(qtyLineRe);
        if (qtyMatch) {
          pendingQtyKg = parseFloat(qtyMatch[1].replace(',', '.'));
          continue;
        }

        // Check for count multiplier (e.g. "2 x 1,49")
        const countMatch = line.match(countLineRe);
        if (countMatch) {
          pendingCount = parseInt(countMatch[1]);
          continue;
        }

        // Check if line has a price at the end → it's a product
        const pm = line.match(priceRe);
        if (pm) {
          let name = line.replace(priceRe, '').trim();
          const price = parseFloat(pm[1].replace(',', '.'));
          // Skip subtotals, totals, payment lines
          if (/^(summe|gesamt|total|bar|karte|zahlung|gegeben|rückgeld|mwst|netto|brutto)/i.test(name)) continue;
          if (/^(zu zahlen|geg\.|eur)/i.test(name)) continue;
          if (!name || name.length < 2) continue;

          let count = pendingCount || 1;
          pendingCount = null;
          let weightKg = pendingQtyKg;
          pendingQtyKg = null;

          items.push({ rawName: name, price, count, weightKg });
        }
      }
      return items;
    }

    // --- Custom mappings (Supabase-backed, shared across devices) ---
    let customMap = {}; // key = normalized rawName, value = { name, unit, category, qty }
    let customMapLoaded = false;

    function normalizeKey(rawName) {
      return rawName.toLowerCase().replace(/\s+/g, ' ').trim();
    }

    async function loadCustomMap() {
      try {
        const rows = await api('/receipt_mappings?select=*');
        customMap = {};
        for (const row of rows) {
          customMap[row.ocr_key] = { name: row.pl_name, unit: row.unit, category: row.category, qty: row.qty, id: row.id };
        }
        customMapLoaded = true;
      } catch (err) {
        // Table might not exist yet — fall back to localStorage
        console.warn('receipt_mappings table not available, using localStorage:', err.message);
        try { customMap = JSON.parse(localStorage.getItem('receipt_custom_map') || '{}'); }
        catch { customMap = {}; }
      }
    }

    // Match a German receipt item name: custom map first, then built-in DE_PL_MAP
    function matchReceiptItem(rawName) {
      const key = normalizeKey(rawName);

      // 1. Check custom map (user corrections) — exact match on normalized name
      if (customMap[key]) {
        return { ...customMap[key], fromCustom: true };
      }

      // 2. Built-in DE→PL map — keyword matching
      const lower = rawName.toLowerCase()
        .replace(/ä/g, 'ae').replace(/ö/g, 'oe').replace(/ü/g, 'ue').replace(/ß/g, 'ss');
      const lowerOrig = rawName.toLowerCase();

      let bestKey = null;
      let bestLen = 0;
      for (const k of Object.keys(DE_PL_MAP)) {
        if ((lowerOrig.includes(k) || lower.includes(k)) && k.length > bestLen) {
          bestKey = k;
          bestLen = k.length;
        }
      }
      if (bestKey) return { ...DE_PL_MAP[bestKey] };

      return null;
    }

    // Save a correction to Supabase (upsert by ocr_key)
    async function saveCorrection(rawName, plData) {
      const key = normalizeKey(rawName);
      const row = { ocr_key: key, pl_name: plData.name, unit: plData.unit, category: plData.category, qty: plData.qty };

      try {
        if (customMap[key] && customMap[key].id) {
          // Update existing
          await api('/receipt_mappings?id=eq.' + customMap[key].id, {
            method: 'PATCH',
            body: JSON.stringify(row)
          });
        } else {
          // Insert new
          const result = await api('/receipt_mappings', {
            method: 'POST',
            body: JSON.stringify(row)
          });
          if (result && result[0]) row.id = result[0].id;
        }
        customMap[key] = { name: plData.name, unit: plData.unit, category: plData.category, qty: plData.qty, id: row.id };
      } catch (err) {
        // Fallback to localStorage if table doesn't exist
        console.warn('Could not save to Supabase, using localStorage:', err.message);
        customMap[key] = { name: plData.name, unit: plData.unit, category: plData.category, qty: plData.qty };
        localStorage.setItem('receipt_custom_map', JSON.stringify(customMap));
      }
    }

    let scannedItems = []; // { rawName, price, count, weightKg, plMatch, selected }

    async function scanReceipt(input) {
      const file = input.files[0];
      if (!file) return;

      const content = document.getElementById('receipt-content');
      content.innerHTML = '<div class="receipt-progress">'
        + '<div>Skanowanie paragonu...</div>'
        + '<div class="bar"><div class="bar-fill" id="ocr-bar" style="width:0%"></div></div>'
        + '<div id="ocr-status">Ładowanie OCR...</div>'
        + '</div>';

      try {
        // Load Tesseract.js from CDN
        if (!window.Tesseract) {
          await new Promise((resolve, reject) => {
            const s = document.createElement('script');
            s.src = 'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js';
            s.onload = resolve;
            s.onerror = reject;
            document.head.appendChild(s);
          });
        }

        const bar = document.getElementById('ocr-bar');
        const status = document.getElementById('ocr-status');

        const worker = await Tesseract.createWorker('deu', 1, {
          logger: m => {
            if (m.status === 'recognizing text') {
              const pct = Math.round((m.progress || 0) * 100);
              bar.style.width = pct + '%';
              status.textContent = 'Rozpoznawanie tekstu... ' + pct + '%';
            }
          }
        });

        const { data } = await worker.recognize(file);
        await worker.terminate();

        // Parse receipt lines
        const receiptLines = parseReceiptLines(data.text);

        if (receiptLines.length === 0) {
          content.innerHTML = '<div class="empty">Nie rozpoznano produktów na paragonie.<br><small>Spróbuj lepsze zdjęcie.</small></div>'
            + '<div class="receipt-upload"><label for="receipt-file">'
            + '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>'
            + 'Spróbuj ponownie</label></div>';
          return;
        }

        // Make sure data is loaded
        if (allItems.length === 0) await loadItems();
        if (!customMapLoaded) await loadCustomMap();

        scannedItems = receiptLines.map(line => {
          const plMatch = matchReceiptItem(line.rawName);
          // Check if item already exists in inventory (by stem matching)
          let existingItem = null;
          if (plMatch) {
            for (const inv of allItems) {
              if (inv.name.toLowerCase() === plMatch.name.toLowerCase()) {
                existingItem = inv;
                break;
              }
              // Also try stem matching
              const score = matchScore(inv.name, plMatch.name);
              if (score > 0) { existingItem = inv; break; }
            }
          }
          return {
            ...line,
            plMatch,
            existingItem,
            selected: !!plMatch // auto-select matched items
          };
        });

        renderScannedItems();
      } catch (err) {
        content.innerHTML = '<div class="empty">Błąd OCR: ' + escapeHtml(err.message) + '</div>';
      }
    }

    function renderScannedItems() {
      const content = document.getElementById('receipt-content');
      let html = '<div style="padding:12px 16px 4px"><b>Rozpoznane produkty (' + scannedItems.length + ')</b></div>';

      const unitOptions = ['g','ml','szt.','opak.','puszka','słoik','butelka','kg'];
      const catOptions = getCategories();

      scannedItems.forEach((item, idx) => {
        const checked = item.selected ? 'checked' : '';
        const plName = item.editName !== undefined ? item.editName : (item.plMatch ? item.plMatch.name : '');
        const plCat = item.editCat !== undefined ? item.editCat : (item.plMatch ? item.plMatch.category : 'Inne');
        const isNew = item.plMatch && !item.existingItem;
        const isUpdate = item.plMatch && item.existingItem;
        const isCustom = item.plMatch && item.plMatch.fromCustom;
        const isUnknown = !item.plMatch && item.editName === undefined;

        // Determine displayed quantity
        let dispQty, dispUnit;
        if (item.editQty !== undefined) {
          dispQty = item.editQty;
          dispUnit = item.editUnit || (item.plMatch ? item.plMatch.unit : 'szt.');
        } else if (item.weightKg) {
          dispQty = Math.round(item.weightKg * 1000);
          dispUnit = 'g';
        } else if (item.plMatch) {
          dispQty = item.plMatch.qty * (item.count || 1);
          dispUnit = item.plMatch.unit;
        } else {
          dispQty = item.count || 1;
          dispUnit = 'szt.';
        }
        if (item.editUnit !== undefined) dispUnit = item.editUnit;

        html += '<div class="scan-item">'
          + '<div class="si-check ' + checked + '" onclick="toggleScanItem(' + idx + ')">' + (item.selected ? '✓' : '') + '</div>'
          + '<div class="si-info">'
          + '<div class="si-de">' + escapeHtml(item.rawName) + ' · ' + item.price.toFixed(2) + '€'
          + (item.count > 1 ? ' x' + item.count : '')
          + (isCustom ? ' <span style="color:var(--green);font-size:11px">zapamiętane</span>' : '')
          + '</div>';

        // Editable product name
        html += '<div class="si-edit" style="margin-top:3px">'
          + '<span style="font-size:12px;color:var(--text-dim);min-width:42px">Nazwa:</span>'
          + '<input type="text" style="flex:1;width:auto" value="' + escapeHtml(plName) + '" '
          + 'placeholder="Wpisz nazwę po polsku" '
          + 'onchange="updateScanName(' + idx + ', this.value)" onclick="event.stopPropagation()">'
          + '</div>';

        // Editable quantity + unit + category
        html += '<div class="si-edit">'
          + '<span style="font-size:12px;color:var(--text-dim);min-width:42px">Ilość:</span>'
          + '<input type="number" step="any" value="' + dispQty + '" onchange="updateScanQty(' + idx + ', this.value)" onclick="event.stopPropagation()">'
          + '<select onchange="updateScanUnit(' + idx + ', this.value)" onclick="event.stopPropagation()">';
        for (const u of unitOptions) {
          html += '<option value="' + u + '"' + (u === dispUnit ? ' selected' : '') + '>' + u + '</option>';
        }
        html += '</select>';

        if (isUpdate) {
          const inv = item.existingItem;
          const qty = inv.quantity === Math.floor(inv.quantity) ? Math.floor(inv.quantity) : inv.quantity;
          html += '<span class="si-qty">masz: ' + qty + ' ' + escapeHtml(inv.unit) + '</span>';
        } else if (isNew || plName) {
          html += '<span class="si-new">+ nowy</span>';
        }

        html += '</div>'; // si-edit qty

        // Category input with autocomplete
        html += '<div class="si-edit">'
          + '<span style="font-size:12px;color:var(--text-dim);min-width:42px">Kat.:</span>'
          + '<input type="text" list="scan-cat-list" style="flex:1;width:auto" value="' + escapeHtml(plCat) + '" '
          + 'placeholder="Kategoria" '
          + 'onchange="updateScanCat(' + idx + ', this.value)" onclick="event.stopPropagation()">'
          + '</div>';

        html += '</div></div>'; // si-info, scan-item
      });

      // Category datalist for scan items
      html += '<datalist id="scan-cat-list">';
      for (const c of catOptions) { html += '<option value="' + escapeHtml(c) + '">'; }
      html += '</datalist>';

      const selectedCount = scannedItems.filter(i => i.selected).length;
      html += '<div class="scan-actions">'
        + '<button style="background:var(--green);color:#1a1a2e" onclick="addScannedToInventory()">'
        + 'Dodaj do magazynu (' + selectedCount + ')</button>'
        + '</div>';

      // Re-scan option
      html += '<div class="receipt-upload" style="padding-top:0"><label for="receipt-file">'
        + 'Skanuj inny paragon</label></div>';

      content.innerHTML = html;
    }

    function toggleScanItem(idx) {
      scannedItems[idx].selected = !scannedItems[idx].selected;
      renderScannedItems();
    }

    function updateScanName(idx, val) {
      scannedItems[idx].editName = val.trim();
      // Auto-select if user typed a name
      if (val.trim() && !scannedItems[idx].selected) {
        scannedItems[idx].selected = true;
      }
      // If no plMatch yet, create one so it can be saved
      if (!scannedItems[idx].plMatch && val.trim()) {
        scannedItems[idx].plMatch = {
          name: val.trim(),
          unit: scannedItems[idx].editUnit || 'szt.',
          category: scannedItems[idx].editCat || 'Inne',
          qty: scannedItems[idx].editQty || 1
        };
      }
    }

    function updateScanQty(idx, val) {
      scannedItems[idx].editQty = parseFloat(val) || 0;
    }

    function updateScanUnit(idx, val) {
      scannedItems[idx].editUnit = val;
    }

    function updateScanCat(idx, val) {
      scannedItems[idx].editCat = val;
    }

    async function addScannedToInventory() {
      const selected = scannedItems.filter(i => i.selected && (i.plMatch || i.editName));
      if (selected.length === 0) { alert('Zaznacz produkty do dodania.'); return; }

      const names = selected.map(i => (i.editName || (i.plMatch && i.plMatch.name) || i.rawName)).join(', ');
      if (!confirm('Dodać do magazynu?\n\n' + names)) return;

      try {
        for (const item of selected) {
          // Resolve final name, unit, category, qty from edits or plMatch
          const finalName = item.editName || (item.plMatch && item.plMatch.name) || item.rawName;
          const finalCat = item.editCat || (item.plMatch && item.plMatch.category) || 'Inne';
          const count = item.count || 1;

          let addQty, addUnit;
          if (item.editQty !== undefined) {
            addQty = item.editQty;
            addUnit = item.editUnit || (item.plMatch && item.plMatch.unit) || 'szt.';
          } else if (item.weightKg) {
            addQty = Math.round(item.weightKg * 1000);
            addUnit = 'g';
          } else if (item.plMatch) {
            addQty = item.plMatch.qty * count;
            addUnit = item.plMatch.unit;
          } else {
            addQty = count;
            addUnit = 'szt.';
          }
          if (item.editUnit !== undefined) addUnit = item.editUnit;

          // Save correction to custom map for future scans
          saveCorrection(item.rawName, { name: finalName, unit: addUnit, category: finalCat, qty: addQty / Math.max(count, 1) });

          // Re-check if item exists in inventory by name
          let existingItem = item.existingItem;
          if (!existingItem) {
            for (const inv of allItems) {
              if (inv.name.toLowerCase() === finalName.toLowerCase()) {
                existingItem = inv;
                break;
              }
              const score = matchScore(inv.name, finalName);
              if (score > 0) { existingItem = inv; break; }
            }
          }

          if (existingItem) {
            const newQty = existingItem.quantity + addQty;
            await api('/inventory?id=eq.' + existingItem.id, {
              method: 'PATCH',
              body: JSON.stringify({ quantity: newQty })
            });
          } else {
            await api('/inventory', {
              method: 'POST',
              body: JSON.stringify({ name: finalName, quantity: addQty, unit: addUnit, category: finalCat })
            });
          }
        }

        await loadItems();

        const content = document.getElementById('receipt-content');
        content.innerHTML = '<div class="empty" style="color:var(--green)">Dodano ' + selected.length + ' produktów!</div>'
          + '<div class="receipt-upload"><label for="receipt-file">'
          + '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>'
          + 'Skanuj kolejny paragon</label></div>';
      } catch (err) {
        alert('Błąd: ' + err.message);
      }
    }

    // --- Init ---
    loadItems();
    loadCustomMap().then(async () => {
      // Migrate any localStorage mappings to Supabase
      if (customMapLoaded) {
        try {
          const local = JSON.parse(localStorage.getItem('receipt_custom_map') || '{}');
          const keys = Object.keys(local);
          if (keys.length > 0) {
            for (const k of keys) {
              if (!customMap[k]) {
                await saveCorrection(k, local[k]);
              }
            }
            localStorage.removeItem('receipt_custom_map');
          }
        } catch {}
      }
    });
  </script>
</body>
</html>
